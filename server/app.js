// running via babel-node rathan than node means we can use ES6 features - & modules
import 'isomorphic-fetch'

import React from 'react'
import express from 'express'
import fs from 'fs'
// https://reactjs.org/docs/react-dom-server.html#rendertonodestream
import { renderToNodeStream } from 'react-dom/server'
// client side routing executed in the node process.
import { ServerLocation } from '@reach/router'

import App from '../src/app'
import { getRequestData } from './middleware'
import { apiRoutes, clientSettingsRoutes } from './routes'

const isDevelopment = process.env.NODE_ENV === 'development'

const app = express()

const options = {
  index: false,
  dotfiles: 'ignore',
  etag: false,
  maxAge: 0,
  redirect: false,
}

app.use(express.static('./dist', options))
app.use('/api', apiRoutes)
app.use('/client-settings', clientSettingsRoutes)

// use webpack dev server middlare, or express to SRR index.html
if (isDevelopment) {
  // importing on the fly, as it we do this in the head, as it were, as it would run building a
  // development webpack config
  import('./devServerMiddleware').then(module => {
    const { setUpDevServerMiddleware } = module
    setUpDevServerMiddleware(app) // catch all requests with dev server middleware, essentially
  })
} else {
  // As per the PoC, this handles SSR for the intial full page request
  app.get('*', getRequestData, (req, res) => {
    // moved here temporarily while looking at dev server - running in Dev mode means the
    // dist/index.html file will not have been pre-generated by a Production build.
    // to be refactored and improved.
    const html = fs.readFileSync('dist/index.html').toString()
    const htmlParts = html.split('React Application')
    const headParts = htmlParts[0].split('Meta Title')
    const headSubParts = headParts[1].split('Meta Description')

    const clientSettings = req.clientSettings
    const ssrPageData = req.pageData

    const bootstrapData = `
    <script>
      window.BOOTSTRAP = ${JSON.stringify({
        clientSettings,
        ssrPageData,
      })}
    </script>`

    // inject title and description into static html for head
    const head = `
    ${headParts[0]}
    ${ssrPageData.title}
    ${headSubParts[0]}
    ${ssrPageData.description}
    ${headSubParts[1]}
    ${bootstrapData}`

    // this will allow the client to start processing the head, downloading css, while we are SSRing
    // the React application markup.
    res.write(head)

    const reactMarkUp = (
      <ServerLocation url={req.url}>
        <App clientSettings={clientSettings} ssrPageData={ssrPageData} />
      </ServerLocation>
    )

    const reactMarkUpStream = renderToNodeStream(reactMarkUp)

    // pipe the markup through to the response stream.
    // we pass the {end: false} option as when this stream sends all it's data, we're not done yet - we'll be
    // sending the remainder of the index.html markup. after that we're done.
    reactMarkUpStream.pipe(
      res,
      { end: false },
    )

    // when the mark up stream has completed writing to the response stream...
    reactMarkUpStream.on('end', () => {
      res.write(htmlParts[1])
      res.end()
    })
  })
}

export default app
